### GnomeSort

考虑一种最简单的基于贪心策略的排序算法：GnomeSort。从头开始每次考察相邻的一对元素，如果是顺序的，就继续往前走；如果是逆序的，就交换两元素并回溯一步。在往回走之后会继续比较移回来的元素和它前面的元素，直到检测出顺序为止。该算法总是企图将遇到的导致逆序的元素放到恰当的位置，以形成一定范围内的有序，所以可见这是一个基于贪心策略的算法。伪代码如下：

```
naiveGnomesort(S[], n)
	for(int i = 1; i < n;)
		if(i < 1 || S[i-1] <= S[i])
			i++;
		else
			swap(S[i-1], S[i]); i--;
```

当前元素`S[i]`与其前一个元素比较，所以`i`从1开始计数，一直到最后一个为`n-1`。遇到全局最小元素就会往回走到`i`为0，此时采取与`S[i-1] <= S[i]`相同的动作，就是往前走。也可想象前面有哨兵元素，这样构成了形式上的一致性。如果遇到逆序对那就交换后往回走一步。

事实上在往回走到实现局部顺序之后，该算法还会一步步比较后面的一段已经是顺序的序列，可以将其优化。所以遇到逆序对时需要记录此时的位置，以便于一步到位回到此处。

我们来分析这种改进算法的行为结构。遇到逆序对时程序就会将导致逆序的元素搬回指定地点，并记录该元素原来的位置，可见每次往回搬某个元素这个**事务**对应于该元素的初始**坐标**，且随着事务的完成，坐标本身是单调递增的。我们可以用一层循环表示这种关系：每遇到新的坐标，要么往回搬（事务），要么不往回搬，这取决于该坐标的元素是否造成逆序；而往回搬这个事务又可以用循环来实现，所以最终得到二重循环。

```
improvedGnomesort(S[], n)
	for(int k = 1; k < n; k++)
		for(int i = k; i > 0 && S[i-1] > S[i]; i--)
			swap(S[i-1], S[i]);
```

内层for循环的条件其实就是原始Gnomesort算法中if条件（往前走的条件）的取非，因为这里是回头走的条件。

简单分析可知算法时间复杂度是O(n^2)。



### BubbleSort

冒泡排序与Gnome排序其实很相似，都是只考察相邻两个元素的大小关系，如果逆序则交换。不同的是：Gnome排序交换逆序对后还会往回走，试图一步到位地让前面都变得有序；冒泡排序交换逆序对后只管往前走，走到头后再返回继续下一轮冒泡。应对逆序对的策略不同，导致两种算法的中间结果的特点不同：Gnome算法前面总是接近有序，Bubble算法后面总是有序。

基本版的BubbleSort伪代码如下所示：

```C++
void Vector<T>::bubbleSort(Rank lo, Rank hi) {  //可以把rank看作int
  while(lo < --hi) {
    for(Rank i = lo; i < hi; i++)
      if(_elem[i] > _elem[i+1])
        swap(_elem[i], _elem[i+1]);
  }
}
```

考虑冒泡排序的优化：在若干次数组遍历（冒泡）之后，可能序列已经达成有序状态，那这时候后面的遍历操作都是做无用功，所以可以创建一个标记将其省去。如何判断序列已经有序？在某次遍历时如果没有进行元素交换操作就表明序列有序。虽然这一次的检查看起来也像是在做无用功，但是确实是无法省去的。根据这种想法，每次遍历时可以设置一个标记变量，如果发生交换则改变标记，最后根据标记情况退出循环即可。伪代码如下：

```c++
void Vector<T>::bubbleSort(Rank lo, Rank hi) {
  while(!bubble(lo, hi--));
}
bool Vector<T>::bubble(Rank lo, Rank hi) {
  bool sorted = true;  //标记
  while(++lo < hi)
    if(_elem[lo-1] > _elem[lo]) {  //逆序
      sorted = false;
      swap(_elem[i-1], _elem[i]);
    }
  return sorted;
}
```

这里将bubble操作从bubbleSort函数中抽离出来，这样`lo`和`hi`就是传值，`lo`就可以当作之前的`i`来使用。两个函数中`lo`和`hi`，他们的自增自减操作以及数组中坐标的表示都是**相互耦合**的，一定要仔细斟酌。
