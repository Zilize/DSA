### 栈排序

先回忆插入排序`Insertion sort`，其将一个序列分成两部分，前面一部分叫做`prefix`，后面叫做`surfix`。初始时前缀序列为空，后缀序列就是初始序列，在一次次迭代过程中将后缀序列的第一个元素插入到前缀序列的相应位置，使得前缀序列保持有序状态。如下图所示：

![插入排序示意图](http://book.moecode.com/dsa/day0/stacksort/1.png)

而栈排序就是使用栈这种数据结构来具体实现插入排序，有两个栈，分别存放有序序列`prefix`和无序序列`surfix`，还有一个变量用于临时存放数据。其实现过程就是：先将数据放入无序栈中，中间变量存放无序栈的栈顶元素，为其在有序栈中寻找相应的位置；由于栈的出入受到限制，只能从一端出入，所以可一边比较（中间变量与无序栈栈顶元素比较），一遍将阻碍中间变量的元素pop出来push回有序栈中。

举例说明：如下图所示，左边为有序栈，右边为无序栈，中间为栈顶（两栈口相对）；此时从无序栈中取出元素`8`要放入有序栈中，需要将其与有序栈顶比较，如果`8`比较大就可以直接放进左边栈中，否则就让左边腾一个元素到右边，继续进行比较。

![示意图1](http://book.moecode.com/dsa/day0/stacksort/2.png)

由以上的叙述可以抽象出该算法行为的范式就是，依据中间变量与有序栈栈顶比较的结果，采取不同的栈操作，最终使得空栈变为满的有序栈，无序栈变为空栈。

上述实现的算法还有一个特点，就是除了初始空间以外只用了一个变量的空间，其余的操作都在原来的数据结构中进行（其实原始的插入排序更明显，完全在一个数组加一个变量中进行），这种特点命名为`in-place`意为`就地`，其空间复杂度也为常数级。

将有序栈命名为`S`意为Sorted，将无序栈命名为`R`意为Random，构建栈排序函数stackSort()，输入为无序栈`R`，希望输出结果为有序栈。可以初步构思得到伪代码如下：

```
stackSort(stack<int> R):
  stack<int> S;
  int t = R.pop();
  while(!R.empty())
  	if(S.top() <= t)  //如果不影响有序性则直接放进去
    	S.push(t); t = R.pop();
    else  //否则让有序栈栈顶退化为无序状态
    	R.push(S.pop());
  S.push(t);
  return S;

#注意：1.这里用缩进而不是花括号表示代码块；2.这段代码是不完备的，分析见下文。

```

注意倒数第二行可以由考虑边界情况得来：一方面如果整个初始序列只有一个元素，则循环根本没被执行，如果直接返回空的S显然是不对的，所以要将中间变量（也就是无序栈中那唯一的元素）放入栈；另一方面如果判断得到R空了，但是刚刚还提出来一个元素放进了中间变量，还没处理所以不能返回。这两种边界情况都引导我们加上倒数第二句。

事实上上面的伪代码是`不完备`的，问题出在if条件中，一开始栈为空怎么能读取栈顶呢？所以该判断条件应该改为`S.empty() || S.top() <= t`，记得回想逻辑与或的**短路运算**性质。进一步理解：可以假想栈底有一个**哨兵**，它比放进栈的任何数都要小，栈为空也就意味着“中间元素和哨兵进行比较”，由哨兵的性质可知这次比较必然满足`<=`，这样一来上面的判断条件中，逻辑或两边的条件就在数学上实现了统一，也就是都进行了小于或等于的比较。

> 这种假想一个边界条件从而获得形式上统一的想法，是否很有物理的味道？

还可以思考，程序的执行过程中有多少次满足了`S.empty()`这个条件呢？一开始肯定算一次，后面的情况中：如果进来的元素比栈底大，那附加在后面不至于将栈底都给掏出来；如果进来的比栈底还小，那就不得不将有序栈的元素全部退化为无序（退回无序栈），这是就满足一次条件了；如果相等，由于伪代码中if内的判断条件是小于或等于，那么相等的几个数，后面来的还是排在后面，不会跑到前面去，所以也不会满足条件。因此，条件满足的次数是初始无序栈中，**小于栈顶元素的个数值加一**。

值得一提的是，上面提到的`<=`条件使得该算法具有**稳定性**，这种性质在局部看来并没有太大意义，但是放在宏观角度来分析就会来带本质区别，细细体会。



### 直方图最大矩形

该问题的背景是，在一个不规则的图形中获得其所容纳的最大矩形，其中最大指的是面积最大。背景问题可以逐步规约为求直方图最大矩形面积，直方图最大矩形问题`Max Rectangle in a Histogram`的图示如下，其中橙色部分为找到的最大矩形。

![问题图示](http://book.moecode.com/dsa/day0/maxrect/1.png)

解决问题从蛮力算法`Brute-force Algorithm`开始，最大矩形必然是所有矩形所构成的集合中的一个元素，那么可以计算所有矩形的面积并从中找到最大值。矩形由连续相邻的一个或若干个小矩形构成，所以矩形个数为`n + (n - 1) + ... + 1`为平方量级，所以总的复杂度为O(n^2)。

但这种蛮力算法未免太过直接，我们可以观察可能是最大矩形的特征，从而剔除掉一些明显不可能是最大矩形的候选者。如下图所示，pivot是一个极小值点，要想经过它得到一个面积最大的矩形，显然是从该点起尽可能向左右扩展所得到的矩形。向左右扩展到什么时候为止呢？当然是遇到直方图的边界或者第一个小于pivot高度的点，我们将这种点叫做`卡位点`。只有符合上述局部最大的矩形才有可能是全局最大矩形。

![极大矩形](http://book.moecode.com/dsa/day0/maxrect/2.png)

所以改进的蛮力算法是，从头到尾每个小矩形都作为一次pivot，找到n个或n个以下（不同pivot对应的局部最大矩形可能相同）的候选极大矩形，再将他们进行比较。主要的计算过程为对于给定pivot找到从它出发向左向右遇到的第一个比它小的点（卡位点，可分别记作i<sub>k</sub>和j<sub>k</sub>，k为当前pivot），要注意边界可以视作高度值为`-1`的哨兵点，同样构成形式上的统一。这样的操作复杂度和遍历操作差不多，且又有n次这样的操作，最后在n个或以下的候选矩形中找到最大的需要O(n)，最终的复杂度仍为O(n^2)。当然已经比直接的蛮力算法更快了。

一般来说蛮力考虑之后是贪心/减治/分治。这里考虑分治`Divide and Conquer`：分治就是将大问题分成若干小问题，小问题得到小结果后汇总成大结果。在这里可以根据pivot点将直方图分成左右两边，当前直方图的最大矩形必然是以下三者之一：

- 左边直方图的最大矩形
- 右边直方图的最大矩形
- 经过pivot点的最大矩形（从pivot向左右尽可能延伸）

这种思路得到的算法框架大致为：

```
maxRect(H, lo, hi):  //lo和hi是直方图H的子直方图的边界坐标
  k = findPivot(H, lo, hi);  //就是找最小值
  return max{maxRect(H, lo, k), maxRect(H, k+1, hi), H[k] * (hi - lo)};

#注意：1.区间是左闭右开；2.初值：lo = 0, hi = n。
```

分析其复杂度：规模为n时，T(n) = 2T(n/2) + O(n)，这是数据分布比较无序的情况，递推下去得到O(nlogn)；如果是最坏情况，数据有序分布，T(n) = T(n-1) + O(n)，递推得到O(n^2)。最坏情况仍不尽人意。

接下来介绍基于**单调栈**的复杂度只有O(n)的算法。回顾改进的蛮力算法，在所有的局部极大矩形中得到最大矩形固然没错，但是每次获得局部极大矩形就都用了复杂度为O(n)的操作，这是不是有点浪费，或者说干了重复的工作？假想一下，如果让pivot找左右第一个小于自己的点时唾手可得，也就是一步到位，那整个算法的复杂度岂不是降到了O(n)？

因此我们希望构造这样一种栈结构：对于当前的栈顶k，栈顶的下一个元素（次栈顶）为k的左卡位点i<sub>k</sub>，再下一个元素又是i<sub>k</sub>的左卡位点，以此类推。当遇到一个新的元素时，如果该元素高度大于或等于栈顶元素的高度，那么栈顶就是该元素的左卡位点，所以让该元素如栈；如果该元素高度小于栈顶元素高度，那么表示栈顶元素遇到了它的右卡位点（也就是当前遇到的元素），所以去计算栈顶元素对应的极大矩形的面积，并与记录在案的当前最大面积比较，视情况更新当前最大值，而此时这个栈顶元素已经不可能是别的元素的左卡位点（因为右边遇到了比它更小的），所以它在栈中的使命结束了，也就需要pop出来。

这样构成了一种行为范式，也就是视当前遇到元素与当前栈顶元素的大小比较情况，分别将新元素如栈，或者将栈顶弹出并计算其对应的极大矩形（收割结果），这个过程也就是循环体。这样得到的栈从栈底到栈顶，前者依次都是后者的左卡位点或者高度相等，所以必然是单调非减，所以叫做**单调栈**。伪代码如下：

```
maxRect(H, n):
	stack<int> M;  //M就是单调栈
  int maxRect = 0;
  for(int k = 0; k < n;)
  	if(H[M.top()] <= H[k])
    	M.push(k); k++;  //新元素入栈
    else
    	t = M.pop();
      maxRect = max{maxRect, H[t] * (k - M.top() - 1)};
  return maxRect;

#注意：此代码不完备。
```

> 凡遇到取栈顶或出栈操作都要考虑是否满足前置条件，也就是栈非空。

所以第五行的取栈顶操作需要用短路运算去保护，条件应该是`M.empty() || H[M.top()] <= H[k]`。那倒数第三行呢？这个不用，因为不满足if条件就表明M不可能为空（如果是空就会去执行第一个分支）。倒数第二行的取栈顶操作呢？需要！因为上一句已经有一个元素出栈了，所以要检查。max中的第二项应改为：

`H[t] * (M.empty() ? k : (k - M.top() - 1))`

事实上可以将空的情况视为最前面有一个哨兵，其坐标值可看作`-1`（序号从0开始），这样`k - M.top() - 1`其实就是`k`，构成形式上的统一。

除了检查非空，原代码还有不完备的地方，就是循环过程对最后一个元素进行操作后，栈中还可能有元素，因为最后一个元素不一定是最小的，所以这时并没有考虑完所有的极大矩形。假想最后也有一个小于所有元素高度的哨兵，那它应该也要算入循环进行操作。

具体实现可以用一个while循环，条件为M栈非空，循环体类似于for循环中的else分支，因为哨兵的高度必定是小于栈中所有元素高度的。最终得到的伪代码如下：

```
maxRect(H, n):
	stack<int> M;  //M就是单调栈
  int maxRect = 0;
  for(int k = 0; k < n;)
  	if(M.empty() || H[M.top()] <= H[k])
    	M.push(k); k++;  //新元素入栈
    else
    	t = M.pop();
      maxRect = max{maxRect, H[t] * (M.empty() ? k : (k - M.top() - 1))};
	while(!M.empty())
    //类似于else分支的处理逻辑
  return maxRect;
```

分析算法的时间复杂度：最主要的操作就是入栈和出栈操作，而每个元素至多一次入栈一次出栈，所以时间复杂度为O(n)。